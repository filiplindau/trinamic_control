#	"$Name:  $";
#	"$Header:  $";
#=============================================================================
#
# file :        TMCM610_motoraxis.py
#
# description : Python source for the TMCM610_motoraxis and its commands. 
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#                TMCM610_motoraxis are implemented in this file.
#
# project :     TANGO Device Server
#
# $Author:  $
#
# $Revision:  $
#
# $Log:  $
#
# copyleft :    European Synchrotron Radiation Facility
#               BP 220, Grenoble 38043
#               FRANCE
#
#=============================================================================
#  		This file is generated by POGO
#	(Program Obviously used to Generate tango Object)
#
#         (c) - Software Engineering Group - ESRF
#=============================================================================
#


import PyTango
import sys
import threading
import time

#==================================================================
#   TMCM610_motoraxis Class Description:
#
#         Control of a single motor axis of a TMCM610 6 axis controller.
#
#==================================================================
# 	Device States Description:
#
#   DevState.ON :       Connected to motor controller
#   DevState.MOVING :   Motor is moving
#   DevState.FAULT :    An error has occurred.
#   DevState.ALARM :    Limitswitch reached
#   DevState.UNKNOWN :  Communication failure
#==================================================================


class TMCM610_motoraxis(PyTango.Device_4Impl):

#--------- Add you global variables here --------------------------

#------------------------------------------------------------------
#	Device constructor
#------------------------------------------------------------------
	def __init__(self, cl, name):
		PyTango.Device_4Impl.__init__(self, cl, name)
		TMCM610_motoraxis.init_device(self)

#------------------------------------------------------------------
#	Device destructor
#------------------------------------------------------------------
	def delete_device(self):
		print "[Device delete_device method] for device", self.get_name()
		self.stopThreadFlag = True
		if self.stateThread.isAlive() == True:
			self.stateThread.join(3)
		self.stopHomingThreadFlag = True
		if self.homingThread.isAlive() == True:
			self.homingThread.join(3)


#------------------------------------------------------------------
#	Device initialization
#------------------------------------------------------------------
	def init_device(self):
		print "In ", self.get_name(), "::init_device()"
		self.set_state(PyTango.DevState.UNKNOWN)
		self.get_device_properties(self.get_device_class())		
		try:
			self.info_stream('Creating device proxy...')
			self.controllerDevice = PyTango.DeviceProxy(self.TMCM610_device)
			self.controllerDevice.command_inout('On')
			self.set_state(PyTango.DevState.ON)
			self.set_status('Connected to motor controller')
		except Exception, e:
			self.error_stream(''.join(('Error connecting to motor controller: ', str(e))))
			self.set_state(PyTango.DevState.UNKNOWN)
			if e[0].reason == 'DB_DeviceNotDefined':
				self.set_status(e[0].desc)
			else:
				self.set_status(e[0].desc)
			
		self.microstepResolution = 16
		# Check if properties are defined:
		try:
			self.Limit0Enable
		except AttributeError:
			self.Limit0Enable = 1
		try:
			self.Limit1Enable
		except AttributeError:
			self.Limit1Enable = 1
		try:
			self.LimitPolarity
			self.debug_stream(''.join(('LimitPolarity: ', str(self.LimitPolarity))))
		except AttributeError:
			self.LimitPolarity = 0
		

		self.setupMotor()
			
		self.threadLock = threading.Lock()
		self.stopThreadFlag = False
		self.stateThread = threading.Thread()
		threading.Thread.__init__(self.stateThread, target=self.readState)
		
		self.stateThread.start()
		self.info_stream('readState thread started.')

		self.stopHomingThreadFlag = False
		self.homingState = False
		self.homingThread = threading.Thread()
		threading.Thread.__init__(self.homingThread, target=self.homeFunction)

#------------------------------------------------------------------
#	Always excuted hook method
#------------------------------------------------------------------
	def always_executed_hook(self):
#		print "In ", self.get_name(), "::always_excuted_hook()"
		pass

	@PyTango.InfoIt()





	def setupMotor(self):
		try:
			self.info_stream(''.join(('MaxCurrentM', str(self.Axis), ' = ', str(self.Motor_current))))
			attrName = ''.join(('MaxCurrentM', str(self.Axis)))
			self.controllerDevice.write_attribute(attrName, self.Motor_current)
		except Exception, e:
			self.error_stream(''.join(('Error setting max current: ', str(e))))
			self.set_state(PyTango.DevState.FAULT)		
		
		try:
			self.info_stream(''.join(('MicrostepResolutionM', str(self.Axis), ' = ', str(self.microstepResolution))))
			attrName = ''.join(('MicrostepResolutionM', str(self.Axis)))
			self.controllerDevice.write_attribute(attrName, self.microstepResolution)		
		except Exception, e:
			self.error_stream(''.join(('Error setting microstep resolution: ', str(e))))
			self.set_state(PyTango.DevState.FAULT)		

		try:
			self.info_stream(''.join(('Limit0EnableM', str(self.Axis), ' = ', str(self.Limit0Enable))))
			attrName = ''.join(('Limit0EnableM', str(self.Axis)))
			self.controllerDevice.write_attribute(attrName, self.Limit0Enable)		
		except Exception, e:
			self.error_stream(''.join(('Error setting limit0enable: ', str(e))))
			self.set_state(PyTango.DevState.FAULT)		

		try:
			self.info_stream(''.join(('Limit1EnableM', str(self.Axis), ' = ', str(self.Limit1Enable))))
			attrName = ''.join(('Limit1EnableM', str(self.Axis)))
			self.controllerDevice.write_attribute(attrName, self.Limit1Enable)		
		except Exception, e:
			self.error_stream(''.join(('Error setting limit1enable: ', str(e))))
			self.set_state(PyTango.DevState.FAULT)		

		try:
			self.info_stream(''.join(('LimitPolarityM', str(self.Axis), ' = ', str(self.LimitPolarity))))
			attrName = ''.join(('LimitPolarityM', str(self.Axis)))
			self.controllerDevice.write_attribute(attrName, self.LimitPolarity)		
		except Exception, e:
			self.error_stream(''.join(('Error setting limitpolarity: ', str(e))))
			self.set_state(PyTango.DevState.FAULT)		

		try:
			self.debug_stream('Retrieving memorized attributes')			
			attrs = self.get_device_attr()
#			self.stepPerUnit = attrs.get_w_attr_by_name('Step_per_unit').get_write_value()			
#			self.info_stream(''.join(('Steps per unit: ', str(self.stepPerUnit))))
#
#			if self.stepPerUnit <= 0.0 or type(self.stepPerUnit) != float:
#				self.error_stream(''.join(('Type of stepPerUnit ', type(self.stepPerUnit))))
#				self.stepPerUnit = 1.0
			self.offset = attrs.get_w_attr_by_name('Offset').get_write_value()
			self.info_stream(''.join(('Offset: ', str(self.offset))))
			if self.offset < 0.0 or type(self.offset) != float:
				self.error_stream(''.join(('Type of offset ', type(self.offset))))
				self.offset = 0.0
			self.velocity = attrs.get_w_attr_by_name('Velocity').get_write_value()
			self.info_stream(''.join(('Velocity: ', str(self.velocity))))
			self.acceleration = attrs.get_w_attr_by_name('Acceleration').get_write_value()
			self.info_stream(''.join(('Acceleration: ', str(self.acceleration))))
		except:
			self.error_stream('Offset or step per unit set error')
			self.stepPerUnit = 1.0
			self.offset = 0.0
			self.velocity = 10
			self.acceleration = 5000


	def readState(self):
		sleepTime = 0.2
		while not self.stopThreadFlag:
			try:
				hostState = self.controllerDevice.state()
				
				if hostState == PyTango.DevState.ON or hostState == PyTango.DevState.MOVING:
					self.threadLock.acquire()
					attrName0 = ''.join(('Limit0M', str(self.Axis)))
					attrName1 = ''.join(('Limit1M', str(self.Axis)))
					attrName2 = ''.join(('SpeedM', str(self.Axis)))
					attr_read = self.controllerDevice.read_attributes([attrName0, attrName1, attrName2])
					values = [attr_read[0].value, attr_read[1].value, attr_read[2].value]
					if values[0] == True and self.Limit0Enable == 1:
						self.set_state(PyTango.DevState.ALARM)
						self.set_status('Limit switch 0 active')
					elif values[1] == True and self.Limit1Enable == 1:
						self.set_state(PyTango.DevState.ALARM)
						self.set_status('Limit switch 1 active')
					else:
						if values[2] != 0:
							self.set_state(PyTango.DevState.MOVING)
							self.set_status('Motor moving')
						else:
							self.set_state(PyTango.DevState.ON)
							self.set_status('Connected to motor controller')
	
					self.threadLock.release()
					time.sleep(sleepTime)
				else:
					self.set_state(PyTango.DevState.FAULT)
					self.set_status(self.controllerDevice.status()) 
					time.sleep(sleepTime * 2)

			except PyTango.DevFailed, e:
				self.set_state(PyTango.DevState.UNKNOWN)
				self.set_status(''.join(('Failed to communicate with motor device server ', self.TMCM610_device)))
#				PyTango.Except.throw_exception(''.join(('Failed to communicate with motor device server ',self.TMCM610_device)),
#											'readState',str(e)) 
				time.sleep(sleepTime * 5)

	def homeFunction(self):
		self.homingState = True
		sleepTime = 0.5
		attrNamePos = ''.join(('PositionM', str(self.Axis)))
		attrNameLimit = ''.join(('Limit0M', str(self.Axis)))
		attrNameSpeed = ''.join(('Speed0M', str(self.Axis)))

		oldPos = self.controllerDevice.read_attribute(attrNamePos).value / self.stepPerUnit
		moveStep = 1.0		
		while not self.stopHomingThreadFlag == True:
			if self.controllerDevice.read_attribute(attrNameLimit).value == False:
				if self.controllerDevice.read_attribute(attrNameSpeed).value == 0:
					newPos = (oldPos - moveStep) * self.stepPerUnit
					self.controllerDevice.write_attribute(attrNamePos, newPos)
				time.sleep(sleepTime)
			else:
				break
		
		limitPos = self.controllerDevice.read_attribute(attrNamePos).value / self.stepPerUnit
		self.controllerDevice.command_inout('SetZeroPosition', self.Axis)
		
		self.homingState = False

#------------------------------------------------------------------
#	Read PositionSteps attribute
#------------------------------------------------------------------
	def read_PositionSteps(self, attr):
		#	Add your own code here
		attrName = ''.join(('PositionM', str(self.Axis)))
		attr_PositionSteps_read = self.controllerDevice.read_attribute(attrName).value
		attr.set_value(attr_PositionSteps_read)


#------------------------------------------------------------------
#	Write PositionSteps attribute
#------------------------------------------------------------------
	def write_PositionSteps(self, attr):
		print "In ", self.get_name(), "::write_PositionSteps()"
		data = attr.get_write_value()
		print "Attribute value = ", data

		#	Add your own code here
		attrName = ''.join(('PositionM', str(self.Axis)))
		self.controllerDevice.write_attribute(attrName, data)


#---- PositionSteps attribute State Machine -----------------
	def is_PositionSteps_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.OFF]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read Speed attribute
#------------------------------------------------------------------
	def read_Speed(self, attr):
		#	Add your own code here
		attrName = ''.join(('SpeedM', str(self.Axis)))
		attr_read = self.controllerDevice.read_attribute(attrName).value
		attr.set_value(attr_read)


#------------------------------------------------------------------
#	Write Speed attribute
#------------------------------------------------------------------
	def write_Speed(self, attr):
		print "In ", self.get_name(), "::write_Speed()"
		data = attr.get_write_value()
		print "Attribute value = ", data

		#	Add your own code here
		attrName = ''.join(('SpeedM', str(self.Axis)))
		self.controllerDevice.write_attribute(attrName, data)


#---- Speed attribute State Machine -----------------
	def is_Speed_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.OFF]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read LimitSwitch0 attribute
#------------------------------------------------------------------
	def read_LimitSwitch0(self, attr):
		#	Add your own code here
		
		attr_LimitSwitch0_read = 1
		attr.set_value(attr_LimitSwitch0_read)


#---- LimitSwitch0 attribute State Machine -----------------
	def is_LimitSwitch0_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.OFF]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read LimitSwitch1 attribute
#------------------------------------------------------------------
	def read_LimitSwitch1(self, attr):
		#	Add your own code here
		
		attr_LimitSwitch1_read = 1
		attr.set_value(attr_LimitSwitch1_read)


#---- LimitSwitch1 attribute State Machine -----------------
	def is_LimitSwitch1_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.OFF]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read Attribute Hardware
#------------------------------------------------------------------
	def read_attr_hardware(self, data):
#		print "In ", self.get_name(), "::read_attr_hardware()"
		pass

#==================================================================
#
#	TMCM610_motoraxis read/write attribute methods
#
#==================================================================




#------------------------------------------------------------------
#	Read Position attribute
#------------------------------------------------------------------
	def read_Position(self, attr):
		#	Add your own code here
		attrName = ''.join(('PositionM', str(self.Axis)))
		attr_Position_read = self.controllerDevice.read_attribute(attrName).value / self.stepPerUnit
		attr.set_value(attr_Position_read)


#------------------------------------------------------------------
#	Write Position attribute
#------------------------------------------------------------------
	def write_Position(self, attr):
		print "In ", self.get_name(), "::write_Position()"
		data = (attr.get_write_value() * self.stepPerUnit)
		print "Attribute value = ", data

		#	Add your own code here
		if self.homingState == False:			
			attrName = ''.join(('PositionM', str(self.Axis)))
			self.controllerDevice.write_attribute(attrName, data)
		else:
			self.info_stream('No new positioning while homing.')


#---- Position attribute State Machine -----------------
	def is_Position_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read Velocity attribute
#------------------------------------------------------------------
	def read_Velocity(self, attr):
		#	Add your own code here
		attrName = ''.join(('SpeedM', str(self.Axis)))
		attr_read = self.controllerDevice.read_attribute(attrName).value / self.stepPerUnit
		attr.set_value(attr_read)


#------------------------------------------------------------------
#	Write Velocity attribute
#------------------------------------------------------------------
	def write_Velocity(self, attr):
		print "In ", self.get_name(), "::write_Velocity()"
		data = int(attr.get_write_value() * self.stepPerUnit)	# Velocity is in units / second
		print "Attribute value = ", data

		#	Add your own code here
		attrName = ''.join(('SpeedM', str(self.Axis)))
		self.controllerDevice.write_attribute(attrName, data)


#---- Velocity attribute State Machine -----------------
	def is_Velocity_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read DialPosition attribute
#------------------------------------------------------------------
	def read_DialPosition(self, attr):
		#	Add your own code here
		attrName = ''.join(('PositionM', str(self.Axis)))
		attr_read = self.controllerDevice.read_attribute(attrName).value / self.stepPerUnit + self.offset
		attr.set_value(attr_read)


#---- DialPosition attribute State Machine -----------------
	def is_DialPosition_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read Offset attribute
#------------------------------------------------------------------
	def read_Offset(self, attr):
		#	Add your own code here
		
		attr_Offset_read = self.offset
		attr.set_value(attr_Offset_read)


#------------------------------------------------------------------
#	Write Offset attribute
#------------------------------------------------------------------
	def write_Offset(self, attr):
		print "In ", self.get_name(), "::write_Offset()"
		data = attr.get_write_value()
		print "Attribute value = ", data

		#	Add your own code here
		if self.homingThread.isAlive() == True:
			self.offset = data


#---- Offset attribute State Machine -----------------
	def is_Offset_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.MOVING,
		                        PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read Acceleration attribute
#------------------------------------------------------------------
	def read_Acceleration(self, attr):
		#	Add your own code here
		attrName = ''.join(('AccelerationM', str(self.Axis)))
		attr_read = self.controllerDevice.read_attribute(attrName).value / self.stepPerUnit
		attr.set_value(attr_read)


#------------------------------------------------------------------
#	Write Acceleration attribute
#------------------------------------------------------------------
	def write_Acceleration(self, attr):
		print "In ", self.get_name(), "::write_Acceleration()"
		data = attr.get_write_value() * self.stepPerUnit
		print "Attribute value = ", data

		#	Add your own code here
		attrName = ''.join(('AccelerationM', str(self.Axis)))
		self.controllerDevice.write_attribute(attrName, data)


#---- Acceleration attribute State Machine -----------------
	def is_Acceleration_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read Deceleration attribute
#------------------------------------------------------------------
	def read_Deceleration(self, attr):
		#	Add your own code here
		attrName = ''.join(('AccelerationM', str(self.Axis)))
		attr_read = self.controllerDevice.read_attribute(attrName).value / self.stepPerUnit
		attr.set_value(attr_read)


#------------------------------------------------------------------
#	Write Deceleration attribute
#------------------------------------------------------------------
	def write_Deceleration(self, attr):
		print "In ", self.get_name(), "::write_Deceleration()"
		data = attr.get_write_value() * self.stepPerUnit
		print "Attribute value = ", data

		#	Add your own code here
		attrName = ''.join(('AccelerationM', str(self.Axis)))
		self.controllerDevice.write_attribute(attrName, data)


#---- Deceleration attribute State Machine -----------------
	def is_Deceleration_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read Base_rate attribute
#------------------------------------------------------------------
	def read_Base_rate(self, attr):
		#	Add your own code here
		
		attr_Base_rate_read = 1.0
		attr.set_value(attr_Base_rate_read)


#------------------------------------------------------------------
#	Write Base_rate attribute
#------------------------------------------------------------------
	def write_Base_rate(self, attr):
		print "In ", self.get_name(), "::write_Base_rate()"
		data = []
		attr.get_write_value(data)
		print "Attribute value = ", data

		#	Add your own code here


#---- Base_rate attribute State Machine -----------------
	def is_Base_rate_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read SimulationMode attribute
#------------------------------------------------------------------
	def read_SimulationMode(self, attr):
		#	Add your own code here
		
		attr_SimulationMode_read = False
		attr.set_value(attr_SimulationMode_read)


#---- SimulationMode attribute State Machine -----------------
	def is_SimulationMode_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read Step_per_unit attribute
#------------------------------------------------------------------
	def read_Step_per_unit(self, attr):
		#	Add your own code here
		print self.stepPerUnit
		attr_Step_per_unit_read = self.stepPerUnit
		attr.set_value(attr_Step_per_unit_read)


#------------------------------------------------------------------
#	Write Step_per_unit attribute
#------------------------------------------------------------------
	def write_Step_per_unit(self, attr):
		print "In ", self.get_name(), "::write_Step_per_unit()"
		data = attr.get_write_value()
		print "Attribute value = ", data

		#	Add your own code here
		self.stepPerUnit = data


#---- Step_per_unit attribute State Machine -----------------
	def is_Step_per_unit_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.MOVING,
		                        PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read Backlash attribute
#------------------------------------------------------------------
	def read_Backlash(self, attr):
		#	Add your own code here
		
		attr_Backlash_read = False
		attr.set_value(attr_Backlash_read)


#------------------------------------------------------------------
#	Write Backlash attribute
#------------------------------------------------------------------
	def write_Backlash(self, attr):
		print "In ", self.get_name(), "::write_Backlash()"
		data = []
		attr.get_write_value(data)
		print "Attribute value = ", data

		#	Add your own code here


#---- Backlash attribute State Machine -----------------
	def is_Backlash_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Read Limit_switches attribute
#------------------------------------------------------------------
	def read_Limit_switches(self, attr):
		#	Add your own code here
		attrName0 = ''.join(('Limit0M', str(self.Axis)))
		attrName1 = ''.join(('Limit1M', str(self.Axis)))
		attr_read = self.controllerDevice.read_attributes([attrName0, attrName1])
		values = [attr_read[0].value, attr_read[1].value]

		attr.set_value(values)


#---- Limit_switches attribute State Machine -----------------
	def is_Limit_switches_allowed(self, req_type):
		if self.get_state() in [PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True



#==================================================================
#
#	TMCM610_motoraxis command methods
#
#==================================================================

#------------------------------------------------------------------
#	Stop command:
#
#	Description: Stop motor
#                
#------------------------------------------------------------------
	def Stop(self):
		print "In ", self.get_name(), "::Stop()"
		#	Add your own code here
		self.controllerDevice.command_inout('Stop')
		self.stopHomingThreadFlag = True
		if self.homingThread.isAlive() == True:
			self.homingThread.join(3)
		self.controllerDevice.command_inout('Stop')


#---- Stop command State Machine -----------------
	def is_Stop_allowed(self):
		if self.get_state() in [PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Abort command:
#
#	Description: Abort motion
#                
#------------------------------------------------------------------
	def Abort(self):
		print "In ", self.get_name(), "::Abort()"
		#	Add your own code here


#---- Abort command State Machine -----------------
	def is_Abort_allowed(self):
		if self.get_state() in [PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	DefinePosition command:
#
#	Description: Define current position in physical units
#                
#	argin:  DevDouble	
#------------------------------------------------------------------
	def DefinePosition(self, argin):
		print "In ", self.get_name(), "::DefinePosition()"
		#	Add your own code here
		self.controllerDevice.command_inout('SetZeroPosition', self.Axis)


#---- DefinePosition command State Machine -----------------
	def is_DefinePosition_allowed(self):
		if self.get_state() in [PyTango.DevState.OFF,
		                        PyTango.DevState.MOVING,
		                        PyTango.DevState.FAULT,
		                        PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#------------------------------------------------------------------
#	Home command:
#
#	Description: Move to home position (Limit 0 active)
#                
#------------------------------------------------------------------
	def Home(self):
		print "In ", self.get_name(), "::Home()"
		#	Add your own code here
		self.homingThread.start()


#---- Home command State Machine -----------------
	def is_Home_allowed(self):
		if self.get_state() in [PyTango.DevState.UNKNOWN]:
			#	End of Generated Code
			#	Re-Start of Generated Code
			return False
		return True


#==================================================================
#
#	TMCM610_motoraxisClass class definition
#
#==================================================================
class TMCM610_motoraxisClass(PyTango.DeviceClass):

	#	Class Properties
	class_property_list = {
		}


	#	Device Properties
	device_property_list = {
		'TMCM610_device':
			[PyTango.DevString,
			"Tango name of the TMCM610 controller device",
			[ "maxlab/tmcm610/01" ] ],
		'Axis':
			[PyTango.DevShort,
			"Number of the axis to control, in the range 0-5.",
			[ 0 ] ],
		'Sleep_before_last_read':
			[PyTango.DevDouble,
			"Motor instability time. Time in ms to wait after motor stop to read last position.",
			[ 0 ] ],
		'Motor_current':
			[PyTango.DevDouble,
			"Maximum current (peak) in A sent to the motor. The motor\nrating is usually in RMS, so this value x sqrt(2) should\nbe used here. Must be below 1.5 A.",
			[ 0.1 ] ],
		'Limit0Enable':
			[PyTango.DevBoolean,
			"Enabling of limit switch 0.",
			[ 1 ] ],
		'Limit1Enable':
			[PyTango.DevBoolean,
			"Enabling of limit switch 1.",
			[ 1 ] ],
		'LimitPolarity':
			[PyTango.DevBoolean,
			"Polarity of motor limit switches (normally open/closed).",
			[ 0 ] ],
		}


	#	Command definitions
	cmd_list = {
		'Stop':
			[[PyTango.DevVoid, ""],
			[PyTango.DevVoid, ""]],
		'Abort':
			[[PyTango.DevVoid, ""],
			[PyTango.DevVoid, ""]],
		'DefinePosition':
			[[PyTango.DevDouble, ""],
			[PyTango.DevVoid, ""]],
		'Home':
			[[PyTango.DevVoid, ""],
			[PyTango.DevVoid, ""]],
		}


	#	Attribute definitions
	attr_list = {
		'Position':
			[[PyTango.DevDouble,
			PyTango.SCALAR,
			PyTango.READ_WRITE]],
		'Velocity':
			[[PyTango.DevDouble,
			PyTango.SCALAR,
			PyTango.READ_WRITE],
			{
				'Memorized':"true_without_hard_applied",
			} ],
		'DialPosition':
			[[PyTango.DevDouble,
			PyTango.SCALAR,
			PyTango.READ],
			{
				'description':"Absolute position with offset applied",
			} ],
		'Offset':
			[[PyTango.DevDouble,
			PyTango.SCALAR,
			PyTango.READ_WRITE],
			{
				'Memorized':"true",
			} ],
		'Acceleration':
			[[PyTango.DevDouble,
			PyTango.SCALAR,
			PyTango.READ_WRITE],
			{
				'description':"Same as deceleration",
				'Memorized':"true_without_hard_applied",
			} ],
		'Deceleration':
			[[PyTango.DevDouble,
			PyTango.SCALAR,
			PyTango.READ_WRITE],
			{
				'description':"Same as acceleration",
				'Memorized':"true_without_hard_applied",
			} ],
		'Base_rate':
			[[PyTango.DevDouble,
			PyTango.SCALAR,
			PyTango.READ_WRITE],
			{
				'description':"What is this??",
			} ],
		'SimulationMode':
			[[PyTango.DevBoolean,
			PyTango.SCALAR,
			PyTango.READ]],
		'Step_per_unit':
			[[PyTango.DevDouble,
			PyTango.SCALAR,
			PyTango.READ_WRITE],
			{
				'Memorized':"true",
			} ],
		'Backlash':
			[[PyTango.DevBoolean,
			PyTango.SCALAR,
			PyTango.READ_WRITE],
			{
				'Memorized':"true_without_hard_applied",
			} ],
		'Limit_switches':
			[[PyTango.DevBoolean,
			PyTango.SPECTRUM,
			PyTango.READ, 3]],
		}


#------------------------------------------------------------------
#	TMCM610_motoraxisClass Constructor
#------------------------------------------------------------------
	def __init__(self, name):
		PyTango.DeviceClass.__init__(self, name)
		self.set_type(name);
		print "In TMCM610_motoraxisClass  constructor"

#==================================================================
#
#	TMCM610_motoraxis class main method
#
#==================================================================
if __name__ == '__main__':
	try:
		py = PyTango.Util(sys.argv)
		py.add_TgClass(TMCM610_motoraxisClass, TMCM610_motoraxis, 'TMCM610_motoraxis')

		U = PyTango.Util.instance()
		U.server_init()
		U.server_run()

	except PyTango.DevFailed, e:
		print '-------> Received a DevFailed exception:', e
	except Exception, e:
		print '-------> An unforeseen exception occured....', e
